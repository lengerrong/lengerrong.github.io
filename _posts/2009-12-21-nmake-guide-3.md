---
layout: post
title: NMAKE Guide (三)
tags: NMAKE
categories: build
---

命令
如果依赖关系过期了，那么NMAKE一定会执行描述块的命令段或是推导规则列出的命令。
您可以在命令段中指定任何在MS-DOS命令行中可以执行的命令或程序（有一些例外，比如一条路径）。
多个命令可以出现在一个命令块中。每条命令（下一节中描述的命令除外）独立出现在一行中。
如果一个描述块中不包含任何命令，NMAKE根据匹配的依赖寻找一个推导规则。（详情见563页的“推导规则”一节。）
下面的例子中描述了跟在依赖行后的两条命令：

myapp.exe : myapp.obj another.obj myapp.def
link myapp another, , NUL, mylib, myapp
copy myapp.exe c:/project

NMAKE将会在每条命令执行前打印该命令，除非你指定了/S选项、.SLIENT指令、!CMDSWITCHES指令或是@命令修饰符。

命令语法
一条命令必须以一个或多个空格或是制表符开始。NMAKE使用这种缩进来区分依赖行和命令行。
依赖行和命令块之间不能出现空白行，但是可以出现只包含空格或是制表符的行；该行被当做空命令行，不会有错误产生。
在命令行之间可以出现空白行。

长的命令可以跨越多行如果每行都以反斜杠结尾（/）。命令行尾的反斜杠被当做空格处理。
举个例子，之前的例子中的LINK命令可以如下描述：

link myapp/
another, , NUL, mylib, myapp

NMAKE将会将连续的几行当做一条长命令传递给操作系统处理。
以反斜杠结尾的连续的长命令的长度仍然不能超过操作系统的命令行的长度的限制。
如果在反斜杠后还有其他的字符，比如空格或制表符，NMAKE将会将反斜杠和尾随字符解释为文字字符（转义字符处理）。
您也可以在依赖行后放置一条简单的命令不管是否有其他的命令存在于缩进的命令块中。
使用分号（;）来分隔最右边的依赖和随后的命令，就像下面的一样：

project.obj : project.c project.h ; cl /c project.c

命令修饰符
命令修饰符为描述块的命令提供了额外的控制功能。您可以使用多个修饰符来修饰一条简单的命令。
在被修饰的命令之前指定特定的命令修饰符，可以选择用空格或制表符分隔。
像命令一样，一个命令修饰符不能出现在一行的开始，它必须跟在一个或多个空格或是制表符之后。

下面描述了三个NMAKE命令修饰符。

@command
禁止NMAKE打印命令。不会禁止命令的任何输出显示。在命令之前可以出现一个或多个空格或是制表符。
默认情况下，NMAKE打印makefile中每条执行的命令。/S选项禁止整个makefile文件中执行命令的打印动作。
.SILENT指令用来禁止部分makefile的命令打印显示。

-[number]command
关闭命令的错误检查动作。在命令之前可以出现一个或多个空格或是制表符。
默认情况下，如果有任一命令返回一个非零退出代码的形式的错误，NMAKE将停止运行。
-修饰符让NMAKE忽略指定命令的错误。如果在减号后还跟着一个数值，那么表示在命令退出代码的值大于该数值情况下，NMAKE将会停止运行。
在减号和数值之间不能出现任何空格或是制表符，它们只能出现在数字和命令之间。（关于数值使用的更多信息，请参阅545页的“命令退出代码”一节。）
/I选项关闭整个makefile的错误检查动作。.IGNORE指令关闭makefile部分命令的错误检查动作。

!command
如果在使用!修饰的命令之前使用了预定义宏“$**”或是“$?"，那么为每个依赖执行该命令。在命令之前可以出现一个或多个空格或是制表符。
"$**”宏定义代表了依赖行中所有的依赖文件。"$?“宏定义代表了在依赖行所有的依赖项中时间戳比目标更早的依赖文件。

例子1
在下面的例子中，@命令修饰符禁止了命令的回显动作：

sort.exe : sort.obj
@ECHO Now Sorting...

ECHO命令的输出结果并没有被禁止。

例子2
在下面的描述块中，如果sample程序返回一个非零的退出代码，NMAKE并不停止；如果sort程序返回一个比5大的退出代码，NMAKE将会停止：

light.lst : light.txt
-sample light.txt
-5 sort light.txt

例子3
有下面的描述块：

print : one.txt two.txt three.txt
!print $** lpt1:

产生下面的命令：

print one.txt lpt1:
print two.txt lpt1:
print three.txt lpt1：

命令退出代码
NMAKE将停止运行如果任一命令或是程序返回任一非零形式的错误代码。错误代码以NMAKE错误信息形式打印。

您可以使用/I或是/K选项、或是.IGNORE指令、或是!CMDSWITCHES指令或是-命令修饰符等方法来控制NMAKE的行为当一个非零的错误返回代码产生时。
另一种退出代码的使用是在预处理中。您可运行一个程序或是命令然后使用!IF指令来测试该命令的退出代码。
更多的信息请查阅575页的”预处理中程序的执行“一节。

文件名部件语法
NMAKE提供了一个语法让您可以在命令的使用，用来代表第一个依赖文件的组件名字。此文件通常是依赖行分号右边列出的第一个文件。
然而，如果一个依赖是由一个推导规则派生而来的，那么NMAKE将会认为推导依赖为第一个依赖文件，领先于任何一个明确声明的依赖项。
如果应用了多个推导规则，那么.SUFFIXES列表决定了依赖的先后次序。
文件名的组成部分包括文件驱动器、路径、基本名称和你指定的扩展名，（后缀）与磁盘上的不一致。

您可以使用如下的语法来表示完整的文件名：

%S

举个例子，有这么一个描述块：

sample.exe : c:/project/sample.obj
LINK $S;

NMAKE将上面的命令处理成：

LINK c:/project/sample.obj

您可以使用下面的语法来代表完整文件名的一部分：

%|[parts]F

其中parts可以是零或以下字符，按任何顺序：

Letter             Description
----------------------------------------------------------------
No letter          Complete name
d                  Drive
p                  Path
f                  File base name
e                  File extension

使用上面的语法，您可以使用"%|F"或是"%|dpfeF"来代表完整的文件名，与”%S“一样。

例子
下面的描述块使用了文件部分语法：

samplet.exe : c:/project/sample.obj
LINK $S, a:%|pfF.exe;

NMAKE解释第一个文件部分为依赖项的路径名，解释第二个文件部分为依赖项的基本文件名，同时使用指定的磁盘符和文件后缀。
上面的命令执行如下:

LINK c:/project/samplet.obj, a:/project/sample.exe;

--------------------------------------------------------------------------------------------
注意：还有另一种代表文件组成部分的方法，详情请参阅556页的”修改文件名的宏定义“一节。
--------------------------------------------------------------------------------------------